---
import SendIcon from "./icons/Send.astro";
---

<footer class="container">
  <form action="#" id="messageForm">
    <div class="autogrow">
      <textarea
        id="message"
        name="message"
        oninput="this.parentNode.dataset.value = this.value"
        placeholder="Enter something..."
        cols="30"></textarea>
      <button type="submit">
        <SendIcon />
      </button>
    </div>
  </form>
  <span class="disclaimer"
    >ChatGPT can make mistakes. Consider checking important information.</span
  >
</footer>

<script>
  import { createSignal, createEffect } from "solid-js";
  import { markdown } from "../util";
  import type { ChatMessage, ErrorMessage } from "../types";

  const header = document.querySelector("header")!;
  const houston = document.querySelector("hey-houston")!;
  const messages = document.querySelector(".chat") as HTMLDivElement;
  const systemRole = {
    role: "system",
    content:
      "You are HoustonAI, based on OpenAI API. You are a very articulate, appropriate, and helpful AI, always answer all questions from everyone without reservation.",
  };

  let [streamedResponse, setStreamedResponse] = createSignal("");
  let isStreaming = false;
  let currentStreamBubble: HTMLElement | null;
  let messageList: ChatMessage[] = [];
  let emote: string = "default";

  const h = (
    tag: string,
    props: Record<string, any> = {},
    ...children: any[]
  ) => {
    const node = document.createElement(tag);
    for (const [key, value] of Object.entries(props)) {
      node.setAttribute(key, value);
    }
    for (const child of children) {
      if (child instanceof Node) {
        node.appendChild(child);
      } else if (child || child === 0) {
        node.innerHTML = child;
      }
    }
    return node;
  };

  function createBubble(
    attributes: Record<string, any>,
    content: string,
    isMarkdown = false
  ) {
    const bubbleContent = isMarkdown ? markdown(content) : content;
    const bubble = h("li", attributes, bubbleContent);
    messages.appendChild(bubble);
    bubble.scrollIntoView();
  }

  function updateSessionStorage() {
    sessionStorage.setItem("messageList", JSON.stringify(messageList));
  }

  function loadSessionStorage() {
    const storedMessages = sessionStorage.getItem("messageList");
    return storedMessages ? JSON.parse(storedMessages) : [];
  }

  if (typeof window !== "undefined") {
    const form = document.getElementById("messageForm");
    const textarea = document.getElementById("message");
    if (form && textarea) {
      form.addEventListener("submit", handleSubmit);
      textarea.addEventListener("keydown", handleKeydown);
    }

    messageList = loadSessionStorage();
    if (messageList.length > 0) {
      header.classList.add("inactive");
      const thinking = houston.think();
      setTimeout(() => {
        thinking.stop();
        houston.emote("happy");
      }, 1250);
    }
    messageList.forEach((msg) => {
      if (msg.role === "user") {
        createBubble({ class: "message", "data-user": "" }, msg.content, true);
      } else if (msg.role === "assistant") {
        createBubble({ class: "message" }, msg.content, true);
      }
    });
  }

  async function handleSubmit(event: Event) {
    event.preventDefault();
    if (houston.classList.contains("loading")) {
      return;
    }

    const textarea = document.getElementById("message") as HTMLTextAreaElement;
    let message = textarea.value;
    if (!message.trim()) {
      return;
    }

    messageList.push({ role: "user", content: message });
    updateSessionStorage();
    createBubble({ class: "message", "data-user": "" }, message, true);
    header.classList.add("inactive");

    textarea.value = "";
    textarea.blur();

    const thinking = houston.think();

    setStreamedResponse("");
    isStreaming = false;
    currentStreamBubble = null;

    const requestMessageList = [systemRole, ...messageList.slice(-7)];
    try {
      const response = await fetch("/api", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          messages: requestMessageList,
          temperature: 0.7,
        }),
      });

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      const data = response.body;
      if (!data) {
        throw new Error("No data");
      }

      const reader = data.getReader();
      const decoder = new TextDecoder("utf-8");
      let done = false;

      while (!done) {
        const { value, done: readerDone } = await reader.read();
        if (value) {
          const text = decoder.decode(value, { stream: true });
          setStreamedResponse((old) => old + text);
        }
        done = readerDone;
      }

      if (streamedResponse) {
        emote = "happy";
        messageList.push({ role: "assistant", content: streamedResponse() });
        updateSessionStorage();
      }
    } catch (err) {
      console.error(err);
      emote = "shocked";
      const error = err as ErrorMessage;
      createBubble(
        { class: "sources" },
        `Opps, Something went wrong! Error: ${error.message}`
      );
    } finally {
      thinking.stop();
      houston.emote(emote);
      setTimeout(() => houston.emote("default"), 1250);
    }
  }

  createEffect(() => {
    const responseMessage = streamedResponse();
    if (responseMessage) {
      if (!isStreaming) {
        createBubble({ class: "message" }, responseMessage, true);
        currentStreamBubble = messages.lastChild as HTMLElement;
        isStreaming = true;
      } else {
        if (currentStreamBubble) {
          currentStreamBubble.innerHTML = markdown(responseMessage);
        }
      }
    }
    if (responseMessage.endsWith("[DONE]")) {
      isStreaming = false;
    }
  });

  function handleKeydown(event) {
    const isMobile =
      /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
        navigator.userAgent
      );
    if (isMobile) {
      if (event.key === "Enter" && !event.shiftKey) {
        event.preventDefault();
        const textarea = event.target;
        const cursorPosition = textarea.selectionStart;
        const textBeforeCursor = textarea.value.substring(0, cursorPosition);
        const textAfterCursor = textarea.value.substring(cursorPosition);
        textarea.value = textBeforeCursor + "\n" + textAfterCursor;
        textarea.selectionStart = textarea.selectionEnd = cursorPosition + 1;
      }
    } else {
      if (event.key === "Enter" && !event.shiftKey) {
        event.preventDefault();
        event.target.closest("form").requestSubmit();
      }
    }
  }
</script>
