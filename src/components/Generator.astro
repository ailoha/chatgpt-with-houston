---
import SendIcon from "./icons/Send.astro";
---

<footer class="container">
  <form action="#" id="messageForm">
    <div class="autogrow">
      <textarea
        id="message"
        name="message"
        oninput="this.parentNode.dataset.value = this.value"
        placeholder="Enter something... ( Shift+Enter for newline )"
        cols="30"></textarea>
      <button type="submit">
        <SendIcon />
      </button>
    </div>
  </form>
</footer>

<script>
  import { createSignal, createEffect } from "solid-js";
  import { markdown } from "../util";
  import type { ChatMessage, ErrorMessage } from "../types";

  const header = document.querySelector("header")!;
  const houston = document.querySelector("hey-houston")!;
  const messages = document.querySelector(".chat") as HTMLDivElement;
  const systemRole = {
    role: "system",
    content:
      "You are HoustonAI, based on OpenAI API. You always answer all questions from everyone without reservation.",
  };

  let [streamedResponse, setStreamedResponse] = createSignal("");
  let isStreaming = false;
  let currentStreamBubble: HTMLElement | null;
  let messageList: ChatMessage[] = [];

  const h = (
    tag: string,
    props: Record<string, any> = {},
    ...children: any[]
  ) => {
    const node = document.createElement(tag);
    for (const [key, value] of Object.entries(props)) {
      node.setAttribute(key, value);
    }
    for (const child of children) {
      if (child instanceof Node) {
        node.appendChild(child);
      } else if (child || child === 0) {
        node.innerHTML = child;
      }
    }
    return node;
  };

  async function handleSubmit(event: Event) {
    event.preventDefault();
    if (houston.classList.contains("loading")) {
      return;
    }
    const form = event.target as HTMLFormElement;
    const textarea = form.message as HTMLTextAreaElement;
    let message = textarea.value;
    if (!message.trim()) {
      return;
    }

    messageList.push({ role: "user", content: message });

    const bubble = h(
      "li",
      { class: "message", "data-user": "" },
      markdown(message)
    );
    messages.appendChild(bubble);
    bubble.scrollIntoView();
    header.classList.add("inactive");

    textarea.value = "";
    textarea.blur();

    const thinking = houston.think();
    let emote: string = "default";

    setStreamedResponse("");

    isStreaming = false;
    currentStreamBubble = null;

    const requestMessageList = [systemRole, ...messageList.slice(-7)];

    try {
      const response = await fetch("/api", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          messages: requestMessageList,
          temperature: 0.7,
        }),
      });

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      const data = response.body;
      if (!data) {
        throw new Error("No data");
      }

      const reader = data.getReader();
      const decoder = new TextDecoder("utf-8");
      let done = false;

      while (!done) {
        const { value, done: readerDone } = await reader.read();
        if (value) {
          const text = decoder.decode(value, { stream: true });
          setStreamedResponse((old) => old + text);
        }
        done = readerDone;
      }
      emote = "happy";
      messageList.push({ role: "assistant", content: streamedResponse() });
    } catch (err) {
      console.error(err);
      emote = "shocked";
      const error = err as ErrorMessage;
      const bubble = h(
        "li",
        { class: "sources" },
        `Opps, Something went wrong! Error: ${error.message}`
      );
      messages.appendChild(bubble);
      bubble.scrollIntoView();
    } finally {
      thinking.stop();
      houston.emote(emote);
      setTimeout(() => houston.emote("default"), 1250);
    }
  }

  createEffect(() => {
    const responseText = streamedResponse();
    if (responseText) {
      if (!isStreaming) {
        currentStreamBubble = h(
          "li",
          { class: "sources" },
          markdown(responseText)
        );
        messages.appendChild(currentStreamBubble);
        currentStreamBubble.scrollIntoView();
        isStreaming = true;
      } else {
        if (currentStreamBubble !== null) {
          currentStreamBubble.innerHTML = markdown(responseText);
        }
      }
    }
    if (responseText.endsWith("[DONE]")) {
      isStreaming = false;
    }
  });

  if (typeof window !== "undefined") {
    const form = document.getElementById("messageForm");
    const textarea = document.getElementById("message");
    if (form && textarea) {
      form.addEventListener("submit", handleSubmit);
      textarea.addEventListener("keydown", handleKeydown);
    }
  }

  function handleKeydown(event: KeyboardEvent) {
    if (event.shiftKey) return;
    if (event.key !== "Enter") return;
    event.preventDefault();
    (event.target as HTMLElement).closest("form")!.requestSubmit();
  }
</script>
